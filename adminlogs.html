<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin Content Management</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fc;
        }

        /* General Styling */
        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 2rem 1rem;
        }

        .card {
            background-color: white;
            padding: 1.5rem;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05), 0 1px 3px rgba(0, 0, 0, 0.02);
        }

        /* Form Elements */
        input[type="text"],
        input[type="date"],
        textarea,
        select {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            margin-top: 0.25rem;
            transition: border-color 0.15s ease-in-out;
        }

        input[type="text"]:focus,
        input[type="date"]:focus,
        textarea:focus,
        select:focus {
            border-color: #4f46e5;
            outline: none;
            box-shadow: 0 0 0 1px #4f46e5;
        }

        .btn-primary {
            background-color: #4f46e5;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-weight: 600;
            transition: background-color 0.2s;
        }

        .btn-primary:hover:not(:disabled) {
            background-color: #4338ca;
        }

        .btn-primary:disabled {
            background-color: #a5b4fc;
            cursor: not-allowed;
        }

        .btn-danger {
            background-color: #ef4444;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-weight: 600;
            transition: background-color 0.2s;
        }

        .btn-danger:hover {
            background-color: #dc2626;
        }

        .subtext {
            font-size: 0.95rem;
        }

        .context {
            font-size: 0.85rem;
        }

        /* Image Upload/URL Toggle Styling */
        .radio-group label {
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            padding: 0.5rem 1rem;
            border: 1px solid #ccc;
            border-radius: 9999px;
            margin-right: 0.5rem;
            transition: all 0.2s;
        }

        .radio-group input[type="radio"]:checked+span {
            background-color: #e0e7ff;
            color: #4f46e5;
            border-color: #4f46e5;
            font-weight: 600;
        }

        .radio-group input[type="radio"] {
            display: none;
        }

        /* Progress Bar */
        #upload-progress-container {
            border: 1px solid #e0e7ff;
            background-color: #f7f9fc;
            border-radius: 4px;
            overflow: hidden;
        }

        #upload-progress-bar {
            height: 8px;
            background-image: linear-gradient(to right, #6366f1, #3b82f6);
            transition: width 0.3s ease;
        }

        /* Confirmation Modal */
        #confirmation-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.4);
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.3s ease-in-out;
        }

        #confirmation-modal-content {
            background: white;
            border-radius: 12px;
            width: 90%;
            max-width: 400px;
            padding: 2rem;
            transform: scale(0.9);
            opacity: 0;
            transition: all 0.3s ease-in-out;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        }

        #confirmation-modal-content.show {
            transform: scale(1);
            opacity: 1;
        }

        /* Toast Notification */
        #toast-container {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 2000;
        }

        .toast {
            min-width: 250px;
            padding: 1rem;
            margin-top: 0.5rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            color: white;
            opacity: 0;
            transform: translateX(100%);
            transition: opacity 0.3s, transform 0.3s;
        }

        .toast.show {
            opacity: 1;
            transform: translateX(0);
        }

        .toast.default {
            background-color: #3b82f6;
        }

        .toast.success {
            background-color: #10b981;
        }

        .toast.error {
            background-color: #ef4444;
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- Header -->
        <header class="flex justify-between items-center mb-6 py-4 border-b border-gray-200">
            <h1 class="text-3xl font-bold text-gray-800">Content Dashboard</h1>
            <div class="flex items-center space-x-4">
                <span id="auth-status" class="text-red-500 font-medium context">Authenticating...</span>
                <a href="#" id="signOutTab" class="text-red-600 hover:text-red-800 font-medium context">Sign Out</a>
            </div>
        </header>

        <!-- Content Submission Form -->
        <section id="content-form-section" class="mb-8">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4 border-b pb-2">Content Submission</h2>
            <form id="content-form" class="card hidden space-y-4">

                <!-- Title & Date -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <label for="title" class="block font-medium text-gray-700 subtext">Title *</label>
                        <input type="text" id="title" required placeholder="Enter content title">
                    </div>
                    <div>
                        <label for="date-published" class="block font-medium text-gray-700 subtext" id="date-label">Date
                            Published *</label>
                        <input type="date" id="date-published" required>
                    </div>
                </div>

                <!-- Author & Category -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <label for="author" class="block font-medium text-gray-700 subtext">Author (Admin Email)</label>
                        <input type="text" id="author" readonly class="bg-gray-100 text-gray-600 cursor-not-allowed">
                    </div>
                    <div>
                        <label class="block font-medium text-gray-700 subtext mb-1">Category *</label>
                        <div id="category-radios" class="flex flex-wrap space-x-3 radio-group">
                            <input type="radio" id="news" name="category" value="news" required checked>
                            <label for="news"
                                class="border border-indigo-400 text-indigo-700 rounded-full text-xs px-3 py-1 bg-indigo-50">
                                <span class="text-sm">News</span>
                            </label>

                            <input type="radio" id="promotions" name="category" value="promotions">
                            <label for="promotions"
                                class="border border-pink-400 text-pink-700 rounded-full text-xs px-3 py-1 bg-pink-50">
                                <span class="text-sm">Promotions</span>
                            </label>

                            <input type="radio" id="schedules" name="category" value="schedules">
                            <label for="schedules"
                                class="border border-teal-400 text-teal-700 rounded-full text-xs px-3 py-1 bg-teal-50">
                                <span class="text-sm">Schedules</span>
                            </label>
                        </div>
                    </div>
                </div>

                <!-- Context (Main Content) -->
                <div>
                    <label for="context" class="block font-medium text-gray-700 subtext">Context (HTML/Markdown
                        Supported) *</label>
                    <textarea id="context" rows="8" required placeholder="Enter the main content or description"></textarea>
                </div>

                <!-- Image Upload Section -->
                <div class="border p-4 rounded-xl bg-gray-50 space-y-3">
                    <label class="block font-medium text-gray-700 subtext mb-2">Image Source</label>
                    <div class="flex space-x-4 radio-group mb-3">
                        <input type="radio" id="radio-upload" name="image-source" value="upload" checked>
                        <label for="radio-upload"
                            class="text-sm border-gray-300 text-gray-700 rounded-full px-4 py-2 hover:bg-gray-100">
                            <span>Upload New Image (WebP Compression)</span>
                        </label>

                        <input type="radio" id="radio-url" name="image-source" value="url">
                        <label for="radio-url"
                            class="text-sm border-gray-300 text-gray-700 rounded-full px-4 py-2 hover:bg-gray-100">
                            <span>Use Direct URL</span>
                        </label>
                    </div>

                    <p id="current-image-status" class="text-xs text-gray-500 mb-2">(No image linked)</p>

                    <!-- Upload File Input -->
                    <div id="image-upload-section">
                        <label for="image-upload" class="block font-medium text-gray-700 context">Choose Image
                            File</label>
                        <input type="file" id="image-upload" accept="image/*"
                            class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100">
                    </div>

                    <!-- URL Input -->
                    <div id="image-url-section" class="hidden">
                        <label for="image-url-input" class="block font-medium text-gray-700 context">Image URL</label>
                        <input type="text" id="image-url-input" placeholder="Paste image URL here">
                    </div>

                    <!-- Progress Bar -->
                    <div id="upload-progress-container" class="mt-3">
                        <div id="upload-progress-bar" style="width: 0%"></div>
                    </div>
                    <p id="upload-progress-text" class="context text-gray-500 mt-1">Ready to upload...</p>
                </div>


                <!-- Form Actions -->
                <div class="flex space-x-4 pt-4">
                    <button type="submit" id="submit-btn" data-mode="create" class="btn-primary flex-grow">
                        Publish Content
                    </button>
                    <button type="button" id="cancel-edit-btn" class="hidden text-gray-600 font-medium hover:text-gray-800 px-4 transition">
                        Cancel Edit
                    </button>
                </div>
            </form>
        </section>

        <!-- Content Management List -->
        <section id="content-management" class="hidden">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4 border-b pb-2">All Content</h2>

            <!-- Filter -->
            <div class="mb-4 flex items-center space-x-2">
                <label for="category-filter" class="font-medium text-gray-700 subtext">Filter by Category:</label>
                <select id="category-filter" class="p-2 border rounded-lg subtext">
                    <option value="all">All</option>
                    <option value="news">News</option>
                    <option value="promotions">Promotions</option>
                    <option value="schedules">Schedules</option>
                </select>
            </div>

            <!-- Content List -->
            <div id="content-list" class="space-y-3">
                <p class="text-gray-500 subtext">Loading content...</p>
            </div>
        </section>
    </div>

    <!-- Confirmation Modal Structure -->
    <div id="confirmation-modal-overlay" class="hidden">
        <div id="confirmation-modal-content" class="text-center">
            <h3 id="modal-title" class="text-xl font-bold text-gray-800 mb-4">Confirm Action</h3>
            <p id="modal-message" class="text-gray-600 mb-6">Are you sure you want to proceed?</p>
            <div class="flex justify-center space-x-4">
                <button id="modal-cancel-btn" class="bg-gray-200 text-gray-700 py-2 px-4 rounded-lg font-medium hover:bg-gray-300 transition">Cancel</button>
                <button id="modal-confirm-btn" class="btn-danger py-2 px-4 rounded-lg font-medium transition">Yes,
                    Proceed</button>
            </div>
        </div>
    </div>

    <!-- Toast Container -->
    <div id="toast-container"></div>

    <script type="module">
        import {
            initializeApp
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import {
            getAuth,
            onAuthStateChanged,
            signOut
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import {
            getFirestore,
            doc,
            getDoc,
            collection,
            addDoc,
            getDocs,
            setDoc,
            updateDoc,
            deleteDoc,
            query,
            orderBy,
            setLogLevel // <-- FIX: Imported setLogLevel
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js"; // <-- FIX: Updated version to 11.6.1

        // ⚠️ IMPORTANT: Add your ImgBB API key here
        const IMGBB_API_KEY = '9c172b429bb052aeb83b23335945328b'; // Get from https://api.imgbb.com/

        // For Firebase JS SDK v7.20.0 and later, measurementId is optional
        const firebaseConfig = {
            apiKey: "AIzaSyBCQWWhERYNCkdloUCXDN7XarMKmB0vhYg",
            authDomain: "sklepaga-74f97.firebaseapp.com",
            projectId: "sklepaga-74f97",
            storageBucket: "sklepaga-74f97.firebasestorage.app",
            messagingSenderId: "9183763865",
            appId: "1:9183763865:web:7ddd196777b2f9a6984708",
            measurementId: "G-C0G7FSQTEV"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        setLogLevel('Debug'); // <-- FIX: Added setLogLevel for full logging

        const authStatus = document.getElementById('auth-status');
        const contentForm = document.getElementById('content-form');
        const titleInput = document.getElementById('title');
        const datePublishedInput = document.getElementById('date-published');
        const dateLabel = document.getElementById('date-label');
        const categoryRadios = document.getElementById('category-radios');
        const contextInput = document.getElementById('context');
        const imageUploadInput = document.getElementById('image-upload');
        const currentImageStatus = document.getElementById('current-image-status');
        const authorInput = document.getElementById('author');
        const submitBtn = document.getElementById('submit-btn');
        const cancelEditBtn = document.getElementById('cancel-edit-btn');
        const contentListEl = document.getElementById('content-list');
        const contentManagement = document.getElementById('content-management');
        const categoryFilter = document.getElementById('category-filter');
        const imageUrlInput = document.getElementById('image-url-input');
        const progressBar = document.getElementById('upload-progress-bar');
        const progressText = document.getElementById('upload-progress-text');
        const radioUpload = document.getElementById('radio-upload');
        const radioUrl = document.getElementById('radio-url');
        const imageUploadSection = document.getElementById('image-upload-section');
        const imageUrlSection = document.getElementById('image-url-section');
        const uploadProgressContainer = document.getElementById('upload-progress-container');
        const signOutTab = document.getElementById('signOutTab');

        // Modal Elements
        const modalOverlay = document.getElementById('confirmation-modal-overlay');
        const modalContent = document.getElementById('confirmation-modal-content');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const modalConfirmBtn = document.getElementById('modal-confirm-btn');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');
        const toastContainer = document.getElementById('toast-container');

        let currentAdminUser = null;
        let editingDocId = null;
        let allContent = [];
        let currentImageUrl = '';

        // --- Custom Alert/Toast and Confirmation Modal Functions ---
        function showToast(message, type = 'default') {
            const toast = document.createElement('div');
            // Added type classes to apply gradient styling
            toast.className = `toast ${type}`;
            toast.textContent = message;
            toastContainer.appendChild(toast);

            setTimeout(() => {
                toast.classList.add('show');
            }, 10);
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => {
                    toast.remove();
                }, 500);
            }, 3000);
        }

        /**
         * Custom confirmation modal replacement for window.confirm() 
         * @param {string} message 
         * @param {string} [title='Confirm Action'] 
         * @returns {Promise<boolean>} 
         */
        function showConfirmation(message, title = 'Confirm Action') {
            return new Promise(resolve => {
                modalTitle.textContent = title;
                modalMessage.textContent = message;

                // Use btn-danger for confirmation button
                modalConfirmBtn.textContent = 'Yes, Delete';
                modalConfirmBtn.classList.remove('btn-neutral', 'bg-red-600', 'hover:bg-red-700'); // Clean up old classes
                modalConfirmBtn.classList.add('btn-danger', 'text-white'); // Apply new unified class

                modalOverlay.classList.remove('hidden');
                setTimeout(() => modalContent.classList.add('show'), 10);

                // Event listener setup for modal close
                let confirmHandler = () => {
                    cleanupAndHide(true);
                };
                let cancelHandler = () => {
                    cleanupAndHide(false);
                };

                modalConfirmBtn.addEventListener('click', confirmHandler, {
                    once: true
                });
                modalCancelBtn.addEventListener('click', cancelHandler, {
                    once: true
                });

                function cleanupAndHide(result) {
                    modalConfirmBtn.removeEventListener('click', confirmHandler);
                    modalCancelBtn.removeEventListener('click', cancelHandler);
                    modalContent.classList.remove('show');
                    setTimeout(() => {
                        modalOverlay.classList.add('hidden');
                        resolve(result);
                    }, 300);
                }
            });
        }
        // --- END: Custom Modal/Toast Functions ---

        // --- Helper Functions ---
        const createBaseSlug = (title) => {
            return title.toLowerCase()
                .trim()
                .replace(/[^\w\s-]/g, '')
                .replace(/[\s_-]+/g, '-')
                .replace(/^-+|-+$/g, '');
        };

        /**
         * Generates a unique slug by checking against all existing content (cached in allContent).
         * @param {string} title - The title to base the slug on.
         * @param {string | null} currentDocId - The ID of the document currently being edited (to exclude it from the check).
         * @returns {Promise<string>} The unique slug.
         */
        async function generateUniqueSlug(title, currentDocId) {
            if (!title) return ''; // Return empty slug if no title

            const baseSlug = createBaseSlug(title);
            let finalSlug = baseSlug;
            let counter = 1;

            // Filter out the current document if editing
            const comparableContent = allContent.filter(c => c.id !== currentDocId);

            // Check for slug duplicates
            while (comparableContent.some(c => c.slug === finalSlug)) {
                counter++;
                finalSlug = `${baseSlug}-${counter}`;
            }
            return finalSlug;
        }

        async function compressImageToWebP(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');

                        // Set canvas dimensions
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0);

                        // Binary search for quality to achieve 40-80KB
                        let minQuality = 0.1;
                        let maxQuality = 0.95;
                        let targetMinSize = 40 * 1024; // 40KB
                        let targetMaxSize = 80 * 1024; // 80KB
                        let attempts = 0;
                        const maxAttempts = 15;

                        const tryCompress = (quality) => {
                            return new Promise((res) => {
                                canvas.toBlob((blob) => {
                                    res({
                                        blob,
                                        size: blob.size,
                                        quality
                                    });
                                }, 'image/webp', quality);
                            });
                        };

                        const findOptimalQuality = async () => {
                            while (attempts < maxAttempts && maxQuality - minQuality > 0.01) {
                                attempts++;
                                const midQuality = (minQuality + maxQuality) / 2;
                                const result = await tryCompress(midQuality);

                                progressText.textContent = `Compressing... ${(result.size / 1024).toFixed(1)}KB (attempt ${attempts})`;

                                if (result.size < targetMinSize) {
                                    minQuality = midQuality;
                                } else if (result.size > targetMaxSize) {
                                    maxQuality = midQuality;
                                } else {
                                    // Perfect! Within range
                                    return result.blob;
                                }
                            }

                            // Return the closest result
                            const finalResult = await tryCompress((minQuality + maxQuality) / 2);
                            return finalResult.blob;
                        };

                        findOptimalQuality().then(resolve).catch(reject);
                    };
                    img.onerror = reject;
                    img.src = e.target.result;
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        async function uploadImageToImgBB(file) {
            if (!file) {
                return currentImageUrl;
            }

            if (!IMGBB_API_KEY || IMGBB_API_KEY === 'YOUR_IMGBB_API_KEY_HERE') {
                throw new Error('ImgBB API key not configured. Please add your API key to the code.');
            }

            progressBar.style.width = '0%';
            progressText.textContent = 'Starting compression...';

            try {
                // Compress and convert to WebP
                progressBar.style.width = '10%';
                const compressedBlob = await compressImageToWebP(file);
                const compressedSize = (compressedBlob.size / 1024).toFixed(1);

                progressBar.style.width = '40%';
                progressText.textContent = `Compressed to ${compressedSize}KB WebP. Uploading...`;

                const base64 = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => {
                        const base64String = reader.result.split(',')[1];
                        resolve(base64String);
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(compressedBlob);
                });

                progressBar.style.width = '60%';
                progressText.textContent = 'Uploading to ImgBB...';

                const formData = new FormData();
                formData.append('image', base64);
                formData.append('name', file.name.replace(/\.[^/.]+$/, '.webp'));

                const response = await fetch(`https://api.imgbb.com/1/upload?key=${IMGBB_API_KEY}`, {
                    method: 'POST',
                    body: formData
                });

                progressBar.style.width = '80%';
                progressText.textContent = 'Processing response...';

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error?.message || 'Upload failed');
                }

                const data = await response.json();

                if (!data.success) {
                    throw new Error('ImgBB upload failed');
                }

                progressBar.style.width = '100%';
                progressText.textContent = `Upload complete! ✅ (${compressedSize}KB)`;
                return data.data.url;

            } catch (error) {
                progressBar.style.width = '0%';
                progressText.textContent = 'Upload failed ❌';
                console.error('ImgBB upload error:', error);
                throw new Error(`Failed to upload to ImgBB: ${error.message}`);
            }
        }

        const getFormData = () => ({
            title: titleInput.value.trim(),
            datePublished: datePublishedInput.value.trim(),
            context: contextInput.value.trim(),
            category: document.querySelector('input[name="category"]:checked')?.value || '',
            author: authorInput.value.trim(),
            authorId: currentAdminUser.uid,
        });

        const setFormData = (data) => {
            titleInput.value = data.title;
            contextInput.value = data.context;
            datePublishedInput.value = data.datePublished || new Date().toISOString().substring(0, 10);

            const categoryRadio = document.querySelector(`input[name="category"][value="${data.category}"]`);
            if (categoryRadio) {
                categoryRadio.checked = true;
                updateDateLabel(data.category);
            }

            authorInput.value = data.author;

            currentImageUrl = data.image || '';
            currentImageStatus.textContent = currentImageUrl ? `(Existing image: ${currentImageUrl.substring(0, 30)}...)` : '(No image linked)';

            radioUpload.checked = true;
            radioUrl.checked = false;
            imageUrlInput.value = currentImageUrl; // Pre-fill URL input for easy viewing/copying
            imageUploadInput.value = '';

            // Automatically select URL mode if there's an existing image that wasn't uploaded via file this session
            if (currentImageUrl && !imageUploadInput.value) {
                radioUrl.checked = true;
                radioUpload.checked = false;
                toggleImageInputVisibility('url');
            } else {
                toggleImageInputVisibility('upload');
            }
        };

        function toggleImageInputVisibility(mode) {
            if (mode === 'upload') {
                imageUploadSection.classList.remove('hidden');
                uploadProgressContainer.classList.remove('hidden');
                imageUrlSection.classList.add('hidden');
            } else if (mode === 'url') {
                imageUploadSection.classList.add('hidden');
                uploadProgressContainer.classList.add('hidden');
                imageUrlSection.classList.remove('hidden');
            }
        }

        function updateDateLabel(category) {
            if (category === 'schedules') {
                dateLabel.textContent = 'Date of the Event';
            } else {
                dateLabel.textContent = 'Date Published';
            }
        }

        async function saveContent(data) {
            if (editingDocId) {
                // Ensure slug is preserved/updated during edit
                const updateData = {
                    ...data,
                    updatedAt: new Date().toISOString()
                };
                await updateDoc(doc(db, "content", editingDocId), updateData);
            } else {
                await addDoc(collection(db, "content"), {
                    ...data,
                    timestamp: Date.now()
                });
            }
        }

        async function fetchAllContent() {
            // Use a query with orderBy for a more stable and predictable fetch, even though we sort locally too.
            // NOTE: orderBy is used here, which is generally discouraged for simple apps without proper index management.
            // The prompt dictates maintaining the original structure, so it's kept.
            const q = query(collection(db, "content"), orderBy("timestamp", "desc"));
            const snapshot = await getDocs(q);
            allContent = [];
            snapshot.forEach(d => allContent.push({
                id: d.id,
                ...d.data()
            }));
        }

        async function updateContentJSON() {
            // Filter out redundant fields if necessary before updating master JSON, though in this case, sending allContent is fine.
            await setDoc(doc(db, "contentJson", "data"), {
                updatedAt: new Date().toISOString(),
                content: allContent
            });
        }

        /**
         * Checks if a content entry has critical null/empty fields.
         * @param {Object} d - The content document data.
         * @returns {boolean} True if a problem is found.
         */
        function checkContentForProblems(d) {
            return !d.title || !d.slug || !d.context || !d.category || !d.datePublished;
        }

        async function renderContentList() {
            contentListEl.innerHTML = '<p class="text-gray-500 subtext">Loading content...</p>';

            await fetchAllContent();

            try {
                const filterValue = categoryFilter.value;
                // Filter is now applied after fetching all content
                const filteredContent = filterValue === 'all' ?
                    allContent :
                    allContent.filter(c => c.category === filterValue);

                if (filteredContent.length === 0) {
                    contentListEl.innerHTML =
                        `<p class="text-gray-500 subtext">No ${filterValue !== 'all' ? filterValue : ''} content found.</p>`;
                    return;
                }

                contentListEl.innerHTML = filteredContent
                    .sort((a, b) => b.timestamp - a.timestamp)
                    .map(d => {
                        const hasProblem = checkContentForProblems(d);
                        const problemClass = hasProblem ? 'bg-red-50/70' : 'bg-white';
                        const problemMessage = hasProblem ? ' <span class="text-red-600 font-bold ml-2">⚠️ DATA PROBLEM: Null field detected.</span>' : '';
                        const problemTitleClass = hasProblem ? 'text-red-700' : 'text-slate-800';

                        return `
                    <div class="p-4 border border-gray-200 rounded-xl flex flex-col sm:flex-row justify-between items-start sm:items-center hover:bg-gray-100 transition duration-150 ${problemClass}">
                        <div class="mb-2 sm:mb-0">
                            <p class="subtext font-semibold ${problemTitleClass}">${d.title || '!!MISSING TITLE!!'} <span class="context font-normal text-gray-500">(${d.category || 'N/A'})</span>${problemMessage}</p>
                            <p class="subtext text-gray-500">
                                By: ${d.author || 'N/A'} -
                                📅 ${d.datePublished ? new Date(d.datePublished).toLocaleDateString() : 'Date N/A'}
                                <span class="context text-gray-400 block sm:inline-block">/slug: ${d.slug || 'N/A'}</span>
                            </p>
                        </div>
                        <div class="space-x-2 flex-shrink-0 mt-2 sm:mt-0">
                            <button data-id="${d.id}" data-action="edit" class="bg-blue-100 text-blue-700 py-1 px-3 rounded-full hover:bg-blue-200 font-medium context">Edit</button>
                            <button data-id="${d.id}" data-action="delete" class="bg-red-100 text-red-700 py-1 px-3 rounded-full hover:bg-red-200 font-medium context">Delete</button>
                        </div>
                    </div>
                `;
                    }).join('');
            } catch (err) {
                console.error("Error fetching content:", err);
                contentListEl.innerHTML = '<p class="text-red-500 subtext">Failed to load content.</p>';
            }
        }

        async function handleEdit(docId) {
            const docData = allContent.find(d => d.id === docId);
            if (docData) {
                editingDocId = docId;
                setFormData(docData);
                submitBtn.textContent = 'Update Content';
                submitBtn.dataset.mode = 'edit';
                cancelEditBtn.classList.remove('hidden');
                window.scrollTo({
                    top: contentForm.offsetTop - 20,
                    behavior: 'smooth'
                });
            } else {
                showToast("Content not found in local cache! Please refresh.", 'error');
            }
        }

        async function handleDelete(docId) {
            // Use custom modal for confirmation
            const confirmed = await showConfirmation("Are you sure you want to delete this content? This action is irreversible.");
            if (!confirmed) return;

            try {
                await deleteDoc(doc(db, "content", docId));
                await fetchAllContent();
                await updateContentJSON();
                showToast("Content deleted successfully! ✅", 'success');
                renderContentList();
            } catch (err) {
                console.error("Error deleting content:", err);
                showToast(`Failed to delete content: ${err.message}`, 'error');
            }
        }

        function resetForm() {
            contentForm.reset();
            submitBtn.textContent = 'Publish Content';
            submitBtn.dataset.mode = 'create';
            cancelEditBtn.classList.add('hidden');
            editingDocId = null;
            currentImageUrl = '';
            currentImageStatus.textContent = '(No image linked)';

            progressBar.style.width = '0%';
            progressText.textContent = "Ready to upload...";

            datePublishedInput.value = new Date().toISOString().substring(0, 10);

            radioUpload.checked = true;
            radioUrl.checked = false;
            toggleImageInputVisibility('upload');

            updateDateLabel('news');

            if (currentAdminUser) {
                authorInput.value = currentAdminUser.email;
            }
        }

        // --- Event Listeners ---

        // Category radio listener to change the date label
        categoryRadios.addEventListener('change', (e) => {
            if (e.target.name === 'category') {
                updateDateLabel(e.target.value);
            }
        });

        // Image source radio listener
        document.querySelectorAll('input[name="image-source"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                toggleImageInputVisibility(e.target.value);
            });
        });

        // Content List listener for Edit/Delete buttons
        contentListEl.addEventListener('click', (e) => {
            const btn = e.target.closest('button');
            if (btn) {
                const docId = btn.dataset.id;
                const action = btn.dataset.action;
                if (action === 'edit') {
                    handleEdit(docId);
                } else if (action === 'delete') {
                    handleDelete(docId);
                }
            }
        });

        // Form Submission Handler
        contentForm.addEventListener('submit', async (e) => {
            e.preventDefault();

            submitBtn.disabled = true;
            submitBtn.textContent = editingDocId ? 'Updating...' : 'Publishing...';
            showToast('Processing request...', 'default');

            try {
                const formData = getFormData();
                let imageUrl = currentImageUrl;
                let isImageUploaded = false;

                // Basic validation for critical fields
                if (!formData.title || !formData.context || !formData.category || !formData.datePublished) {
                    showToast("Title, Context, Category, and Date Published are required fields.", 'error');
                    submitBtn.disabled = false;
                    submitBtn.textContent = editingDocId ? 'Update Content' : 'Publish Content';
                    return;
                }

                // 1. Image Handling
                const imageSource = document.querySelector('input[name="image-source"]:checked')?.value;
                if (imageSource === 'upload' && imageUploadInput.files.length > 0) {
                    // Upload a new file
                    const file = imageUploadInput.files[0];
                    imageUrl = await uploadImageToImgBB(file);
                    isImageUploaded = true;
                } else if (imageSource === 'url') {
                    // Use the provided URL
                    imageUrl = imageUrlInput.value.trim();
                }

                // 2. Slug Generation
                const docIdForSlug = editingDocId;
                // Ensure slug is generated/updated only if the title has changed or if it's a new document
                const existingDoc = allContent.find(c => c.id === editingDocId);
                let newSlug = existingDoc?.slug || '';

                // If creating OR if the title has changed OR if the existing slug is null/empty
                if (!editingDocId || (existingDoc && existingDoc.title !== formData.title) || !existingDoc?.slug) {
                    newSlug = await generateUniqueSlug(formData.title, docIdForSlug);
                }

                // 3. Save to Firestore
                const contentToSave = {
                    ...formData,
                    image: imageUrl, // Update with the new or verified image URL
                    slug: newSlug, // Ensure the slug is always present
                };

                await saveContent(contentToSave);

                // 4. Update JSON cache (Crucial for live front-end data)
                await fetchAllContent();
                await updateContentJSON();

                // 5. Success Message & Cleanup
                showToast(editingDocId ? "Content updated successfully! 🎉" : "Content published successfully! 🎉", 'success');
                resetForm();
                renderContentList();

            } catch (error) {
                console.error("Submission error:", error);
                const errorMessage = error.message.includes('ImgBB') ? error.message : "An unexpected error occurred during submission.";
                showToast(errorMessage, 'error');
            } finally {
                submitBtn.disabled = false;
                submitBtn.textContent = editingDocId ? 'Update Content' : 'Publish Content';
            }
        });

        // Cancel Edit Handler
        cancelEditBtn.addEventListener('click', resetForm);

        // Sign Out Logic
        signOutTab.addEventListener("click", async (e) => {
            e.preventDefault(); // Prevent the link from navigating immediately
            await signOut(auth);
            window.location.href = "authentication.html";
        });

        // Filter Listener
        categoryFilter.addEventListener('change', renderContentList);

        // --- Authentication Check ---
        onAuthStateChanged(auth, async (user) => {
            if (!user) {
                // Not authenticated, redirect to login
                window.location.href = "authentication.html";
                return;
            }

            // Check for Admin Role (using the same logic as your dashboard)
            try {
                const adminDoc = await getDoc(doc(db, "admin", user.uid));
                if (adminDoc.exists()) {
                    currentAdminUser = user;
                    authStatus.textContent = `Authenticated as Admin: ${user.email}`;
                    authStatus.classList.replace('text-red-500', 'text-green-500');
                    authorInput.value = user.email; // Auto-fill author
                    contentForm.classList.remove('hidden'); // Show form
                    contentManagement.classList.remove('hidden'); // Show management
                    resetForm(); // Initialize form state
                    renderContentList(); // Load content
                } else {
                    // Authenticated but not an admin
                    // Changed alert() to showToast and console.error, then redirect
                    console.error("Authorization failed: User is authenticated but lacks admin role.");
                    showToast("You are not authorized to view the admin upload page. Redirecting...", 'error');
                    await signOut(auth);
                    setTimeout(() => {
                        window.location.href = "authentication.html";
                    }, 1000);
                }
            } catch (e) {
                console.error("Admin check failed:", e);
                authStatus.textContent = "Error: Failed to verify admin status.";
                showToast("An error occurred during authorization check. Redirecting...", 'error');
                await signOut(auth);
                setTimeout(() => {
                    window.location.href = "authentication.html";
                }, 1000);
            }
        });
    </script>
</body>

</html>
